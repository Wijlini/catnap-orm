= Features =

 * Mapping is done via a fluent interface
 * Mapped entities inherit from IEntity interface
 * Mapped collections 
   * Automatic loading - lazy or eager as specified per collection
   * Automatic cascading - saves/updates and/or deletes as specified per collection
   * Filtering.  Specify a filter criteria for a collection
 * Control connection and transaction boundaries via a basic !UnitOfWork context
 * `Repository<T>` base class provides basic operations
 * `IFindSpec<T>` provides means to abstract find queries
 * !DbCommandSpec provides a way to create and execute any parameterized query (similar to IDbCommand)
 * Support for Linq predicates for finding and filtering collections (very limited
 * Database migration utility. Provides automatic deployment of database changes based on migrations (forward only) that you write)
 * No dependencies except sqlite3.dll

= Configuration =

Something like this at startup:

{{{
SessionFactory.Initialize("MyDatabase.sqlite");
DomainMap.Configure
    (
    new EntityMap<Person>()
        .Property(x => x.Id)
        .Property(x => x.FirstName)
        .Property(x => x.LastName),
    new EntityMap<Forum>()
        .Property(x => x.Id)
        .List(x => x.Posts)
        .Property(x => x.Name),
    new EntityMap<Post>("ForumId")
        .Property(x => x.Id)
        .Property(x => x.Title)
        .Property(x => x.Body)
        .BelongsTo(x => x.Poster, "PosterId")
    );
using (UnitOfWork.Start())
{
    DatabaseMigrator.Execute();
}
}}}

= sqlite3.dll =

The sqlite3.dll COM assembly must be in your application directory.

= IEntity =

Mapped entities must implement the IEntity interface.  Entities use an integer primary key  which is assumed to be auto-incremented by the database.

{{{
public interface IEntity
{
    int Id { get; }
    bool IsTransient { get; }
    void SetId(int id);
}
}}}

Catnap also provides a base class, Entity, which implements IEntity and provides the proper equality comparison.  This is for convenience and is not required.

= Usage =

== Get & Save ==

Here we will fetch a forum, change its title, remove a post, and add a post then save the forum.  The Posts collection will be loaded lazily.  The adds/deletes to Posts will be cascaded when the forum is saved.  A connection will be opened and closed, and the whole thing will be wrapped in a transaction.

{{{
using (UnitOfWork.Start())
{
   var person = personRepository.Get(1);
   var forum = forumRepository.Get(1);
   forum.Title = "Annoying Complaints";
   forum.RemovePost(forum.Posts[0]);
   forum.AddPost(new Post { Title = "Please help!", Body "Now!", Person = person });
   forumRepository.Save(forum);
}
}}}

== Find ==

UNDER CONSTRUCTION

=== Parameterized SQL With !DbCommandSpec ===

UNDER CONSTRUCTION

= Priority To Add =

 * Automated tests.  Catnap started as an experimental project and evolved.  It was developed with testability in mind, but not using TDD.  Getting the code under test will be necessary to allow for change and growth.
   * Unit tests, lots of unit tests
   * More integration tests
 * Session cache. Currently there is no caching of fetched entities.  It will greatly improve performance to cache fetched entities.  This is especially important for cascading, which currently retrieves the entire persisted collection in order to detect changes.
 * ...

UNDER CONSTRUCTION